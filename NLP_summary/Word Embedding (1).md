# Word Embedding (1)

Source: https://wikidocs.net/22644, https://wikidocs.net/33520, https://wikidocs.net/22660, https://wikidocs.net/50739, https://wikidocs.net/69141, https://wikidocs.net/22885, https://wikidocs.net/33793, https://wikidocs.net/33930, https://wikidocs.net/50704

---

### 0. 워드 임베딩(Word Embedding)

자연어를 컴퓨터가 이해하고, 효율적으로 처리하게 하기 위해서는 컴퓨터가 이해할 수 있도록 자연어를 적절히 변환할 필요가 있다.
단어를 표현하는 방법에 다라서 NLP의 성능이 크게 달라지기 때문에 이에 대한 많은 연구가 있었고, 여러가지 방법들ㅇ이 알려져 있다.

최근에는 단어의 의미를 벡터화시킬 수 있는 Word2Vec과 Glove가 많이 사용되고 있다.

---

### 1. Word Embedding

워드 임베딩(Word Embedding)은 단어를 벡터로 표현하는 방법으로, 단어를 밀집 표현으로 변환한다.

---

### 1.1 희소 표현(Sparse Representation)

원-핫 인코딩을 통해서 나온 원-핫 벡터들은 표현하고자 하는 단어의 인덱스의 값만 1이고, 나머지 인덱스에는 전부 0으로 표현되는 벡터 표현 방법이다.
이렇게 벡터 또는 행렬(matrix)의 값이 대부분이 0으로 표현되는 방법을 희소 표현(sparse representation)이라고 한다.
그럼 원-핫 벡터는 희소 벡터(sparse vector)이다.

이러한 희소 벡터의 문제점은 단어의 개수가 늘어나면 벡터의 차원이 한 없이 커진다는 점이다.
원-핫 벡터로 표현할 때는 갖고 있는 코퍼스에 단어가 10,000개였다면 벡터의 차원은 10,000이어야만 했다.
심지어 그 중에서 단어의 인덱스에 해당되는 부분만 1이고 나머지는 0의 값을 가져야만 했다.
단어 집합이 클 수록 고차원의 벡터가 된다.
예를 들어 단어가 10,000개 있고 강아지란 단어의 인덱스는 5였다면 원-핫 벡터는 이렇게 표현되어야 했다.

- Ex) 강아지 = [ 0 0 0 0 1 0 0 0 0 0 0 0 ... 중략 ... 0 ]
  이 때 1 뒤의 0의 수는 9995개

이러한 벡터의 표현은 공간적 낭비를 불러일으킨다.
잘 생각해보면, 공간적 낭비를 일으키는 것은 원-핫 벡터뿐만은 아니다.
희소 표현의 일종인 DTM과 같은 경우에도 특정 문서에 여러 단어가 다수 등장하였으나, 다른 많은 문서에서는 해당 특정 문서에 등장했던 단어들이 전부 등장하지 않는다면 역시나 행렬의 많은 값이 0이 되면서 공간적 낭비를 일으킨다.
뿐만 아니라, 원-핫 벡터는 단어의 의미를 담지 못한다는 단점을 가지고 있다.

---

### 1.2 밀집 표현(Dense Representation)

희소 표현과 반대되는 표현이 있으니, 이를 밀집 표현(Dense Representation)이라고 한다.
밀집 표현은 벡터의 차원을 단어 집합의 크기로 상정하지 않는다.
사용자가 설정한 값으로 모든 단어의 벡터 표현의 차원을 맞춘다.
또한, 이 과정에서 더 이상 0과 1만 가진 값이 아니라 실수값을 가지게 된다.
다시 희소 표현의 예를 가져와 보자.

- Ex) 강아지 = [ 0 0 0 0 1 0 0 0 0 0 0 0 ... 중략 ... 0 ]
  이 때 1 뒤의 0의 수는 9995개

예를 들어 10,000개의 단어가 있을 때 강아지란 단어를 표현하기 위해 위와 같은 표현을 사용했다.
하지만 밀집 표현을 사용하고, 사용자가 밀집 표현의 차원을 128로 설정한다면, 모든 단어의 벡터 표현의 차원은 128로 바뀌면서 모든 값이 실수가 된다.

- Ex) 강아지 = [0.2 1.8 1.1 -2.1 1.1 2.8 ... 중략 ...]
  이 벡터의 차원은 128

이 경우 벡터의 차원이 조밀해졌다고 하여 밀집 벡터(dense vector)라고 한다.

---

### 1.3 워드 임베딩(Word Embedding)

단어를 밀집 벡터(dense vector)의 형태로 표현하는 방법을 워드 임베딩(word embedding)이라고 한다.
그리고 이 밀집 벡터를 워드 임베딩 과정을 통해 나온 결과라고 하여 임베딩 벡터(embedding vector)라고도 한다.

워드 임베딩 방법론으로는 LSA, Word2Vec, FastText, Glove 등이 있다.
케라스에서 제공하는 도구인 Embedding()는 앞서 언급한 방법들을 사용하지는 않지만, 단어를 랜덤한 값을 가지는 밀집 벡터로 변환한 뒤에, 인공 신경망의 가중치를 학습하는 것과 같은 방식으로 단어 벡터를 학습하는 방법을 사용한다.
아래의 표는 원-핫 벡터와 임베딩 벡터의 차이를 보여준다.

|     -     |        원-핫 벡터        |       임베딩 벡터        |
| :-------: | :----------------------: | :----------------------: |
|   차원    | 고차원(단어 집합의 크기) |          저차원          |
| 표현 방법 |           수동           | 훈련 데이터로부터 학습함 |
| 값의 타입 |          1과 0           |           실수           |

---

### 2. 워드투벡터(Word2Vec)

원-핫 벡터는 단어 간 유사도를 계산할 수 없다는 단점이 있다.
그래서 단어 간 유사도를 반영할 수 있도록 단어의 의미를 벡터화 할 수 있는 방법이 필요하다.
그리고 이를 위해 사용되는 대표적인 방법이 Word2Vec이다.

![img](https://wikidocs.net/images/page/22660/word2vec.PNG)

위 사이트는 한국어 단어에 대헤서 벡터 연산을 해볼 수 있는 사이트이다.
위 사이트에서는 단어들로 더하기, 빼기 연산을 할 수 있다.
예를 들어 아래의 식에서 좌변을 집어 넣으면, 우변의 답들이 나온다.

- 고양이 + 애교 = 강아지
- 한국 - 서울 + 도쿄 = 일본
- 박찬호 - 야구 + 축구 = 호나우두

신기하게도 단어가 가지고 있는 어떤 의미들을 가지고 연산을 하고 있는 것처럼 보인다.
이런 연산이 가능한 이유는 각 단어 벡터가 단어 간 유사도를 반영한 값을 가지고 있기 때문이다.
어떻게 이런 일이 가능한 것일까.

---

### 2.1 희소 표현(Sparse Representation)

원-핫 인코딩을 통해서 나온 원-핫 벡터들은 표현하고자 하는 단어의 인덱스의 값만 1이고, 나머지 인덱스에는 전부 0으로 표현되는 벡터 표현 방법이었다. 이렇게 벡터 또는 행렬(matrix)의 값이 대부분이 0으로 표현되는 방법을 희소 표현(sparse representation)이라고 한다. 결국 원-핫 벡터는 희소 벡터(sparse vector)이다.

하지만 이러한 표현 방법은 각 단어간 유사성을 표현할 수 없다는 단점이 있었고, 이를 위한 대안으로 단어의 '의미'를 다차원 공간에 벡터화하는 방법을 찾게 되는데, 이러한 표현 방법을 분산 표현(distributed representation)이라고 한다. 그리고 이렇게 분산 표현을 이용하여 단어의 유사도를 벡터화하는 작업은 워드 임베딩(embedding) 작업에 속하기 때문에 이렇게 표현된 벡터 또한 임베딩 벡터(embedding vector)라고 하며, 저차원을 가지므로 밀집 벡터(dense vector)에도 속한다.

---

### 2.2 분산 표현(Distributed Representation)

분산 표현(distributed representation) 방법은 기본적으로 분포 가설(distributional hypothesis)이라는 가정 하에 만들어진 표현 방법이다. 이 가정은 '비슷한 위치에서 등장하는 단어들은 비슷한 의미를 가진다' 라는 가정이다. 강아지란 단어는 귀엽다, 예쁘다, 애교 등의 단어가 주로 함께 등장하는데 분포 가설에 따라서 저런 내용을 가진 텍스트를 벡터화 한다면 저 단어들은 의미적으로 가까운 단어가 된다. 분산 표현은 분포 가설을 이용하여 단어들의 셋을 학습하고, 벡터에 단어의 의미를 여러 차원에 분산하여 표현한다.

이렇게 표현된 벡터들은 원-핫 벡터처럼 벡터의 단어 집합(vocabulary)의 크기일 필요가 없으므로, 벡터의 차원이 상대적으로 저 차원으로 줄어든다. 예를 들어 단어 10,000 개 있고 인덱스가 1부터 시작한다고 하였을 때 강아지란 단어의 인덱스는 5였다면 강아지란 단어를 표현하는 원-핫 벡터는 다음과 같았다.

- Ex) 강아지 = [ 0 0 0 0 1 0 0 0 0 0 0 0 ... 중략 ... 0 ]

1이란 값 뒤에는 0이 9,995개가 있는 벡터가 된다.
하지만 Word2Vec로 임베딩 된 벡터는 굳이 벡터의 차원이 단어 집합의 크기가 될 필요가 없다.
강아지란 단어를 표현하기 위해 사용자가 설정한 차원을 가지는 벡터가 되면서 각 차원은 실수형의 값을 가진다.

- Ex) 강아지 =  [ 0.2 0.3 0.5 0.7 0.2 ... 중략 ... 0.2 ]

요약하면 희소 표현이 고차원에 각 차원이 분리된 표현 방법이었다면, 분산 표현은 저 차원에 단어의 의미를 여러 차원에 분산하여 표현한다.
이런 표현 방법을 사용하면 단어 간 유사도를 계산할 수 있다.

이를 위한 학습 방법으로는 NNLM, RNNLM 등이 있으나 요즘에는 해당 방법들의 속도를 대폭 개선시킨 Word2Vec가 많이 쓰이고 있다.

---

### 2.3 CBOW(Continue Bag of Words)

Word2Vec에는 CBOW(Continue Bag of Words)와 Skip-Gram 두 가지 방식이 있다.
CBOW는 주변에 있는 단어들을 가지고, 중간에 있는 단어들을 예측하는 방법이다.
반대로, Skip-Gram은 중간에 있는 단어로 주변 단어들을 예측하는 방법이다.
메커니즘 자체는 거의 동일하기 때문에 CBOW를 이해한다면 Skip-Gram도 손쉽게 이해 가능하다.
우선 CBOW에 대해서 알아보자.
이해를 위해 간소화된 형태의 CBOW로 설명한다.

- 예문: "The fat cat sat on the mat"

예를 들어서 갖고 있는 코퍼스에 위와 같은 문장이 있다고 하자.
가운데 단어를 예측하는 것이 CBOW라고 했다.
{"The", "fat", "cat", "on", "the", "mat"}으로부터 sat을 예측하는 것은 CBOW가 하는 일이다.
이 때 예측해야 하는 단어 sat을 중심 단어(center word)라고 하고, 예측에 사용되는 단어들을 주변 단어(context word)라고 한다.

중심 단어를 예측하기 위해서 앞, 뒤로 몇 개의 단어를 볼지 결정했다면 이 범위를 윈도우(window)라고 한다.
예를 들어서 윈도우 크기가 2이고, 예측하고자 하는 중심 단어가 sat이라고 한다면 앞의 두 단어인 fat과 cat,그리고 뒤의 단어인 on, the을 참고한다.
윈도우 크기가 n이라고 한다면, 실제 중심 단어를 예측하기 위해 참고하려고 하는 주변 단어의 개수는 2n이 될 것이다.

![img](https://wikidocs.net/images/page/22660/%EB%8B%A8%EC%96%B4.PNG)

윈도우 크기를 정했다면, 윈도우를 계속 움직여서 주변 단어와 중심 단어 선택을 바꿔가며 학습을 위한 데이터 셋을 만들 수 있는데, 이 방법을 슬라이딩 윈도우(sliding window)라고 한다.

위 그림에서 좌측의 중심 단어와 주변 단어의 변화는 윈도우 크기가 2일 때, 슬라이딩 윈도우가 어떤 식으로 이루어지면서 데이터 셋을 만드는지 보여준다.
또한 Word2Vec에서 입력은 모두 원-핫 벡터가 되어야 하는데, 우측 그림은 중심 단어와 주변 단어를 어떻게 선택했을 때에 따라서 각각 어떤 원-핫 벡터가 되는지를 보여준다.
위 그림은 결국 CBOW를 위한 전체 데이터 셋을 보여주는 것이다.

![img](https://wikidocs.net/images/page/22660/word2vec_renew_1.PNG)

CBOW의 인공 신경망을 간단히 도식화하면 위와 같다.
입력층(Input Layer)의 입력으로서 앞, 뒤로 사용자가 정한 윈도우 크기 범위 안에 있는 주변 단어들의 원-핫 벡터가 필요하다.
Word2Vec의 학습을 위해서 이 중간 단어의 원-핫 벡터가 필요하다.

또한 위 그림에서 알 수 있는 사실은, Word2Vec은 딥 러닝(이하 DL) 모델이 아니라는 것이다.
보통 DL이라고 하면, 입력층(이하 IL)과 출력층(이하 OL) 사이의 은닉층(이하 HL)의 개수가 충분히 쌓인 신경망을 학습 할 때를 말하는데 Word2Vec는 IL과 OL 사이에 하나의 HL만 존재한다.
이렇게 HL이 1개인 경우에는 일반적으로 심층신경망(이하 DNN)이 아니라 얕은신경망(이하 SNN)이라고 부른다.
또한 Word2Vec의 HL은 일반적인 HL과는 달리 활성화 함수가 존재하지 않으며 룩업 테이블이라는 연산을 담당하는 층으로 일반적인 은닉층과 구분하기 위해 투사층(이하 PL)이라고 부르기도 한다.

![img](https://wikidocs.net/images/page/22660/word2vec_renew_2.PNG)

CBOW의 인공 신경망을 좀 더 확대하여, 동작 매커니즘에 대해서 상세하게 알아보자.
이 그림에서 주목해야 할 점은 두 가지이다.
하나의 투사층의 크기가 M이라는 점이다.
CBOW에서 투사층의 크기 M은 임베딩하고 난 벡터의 차원이 된다.
다시 말해, 위의 그림에서 투사층의 크기는 M=5이기 때문에 CBOW를 수행하고 나서 얻는 각 단어의 임베딩 벡터의 차원은 5가 될 것이다.

두번째는 IL과 PL 사이의 가중치 W는 V * M 행렬이며, PL에서 OL사이의 가중치 W'는 M * V 행렬이라는 점이다.
여기서 V는 단어 집합의 크기를 의미한다.

